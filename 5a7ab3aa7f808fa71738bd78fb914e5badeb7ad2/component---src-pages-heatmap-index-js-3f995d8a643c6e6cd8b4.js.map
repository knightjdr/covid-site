{"version":3,"sources":["webpack:///./src/utils/round.js","webpack:///./src/utils/debounce.js","webpack:///./src/components/heatmap/heatmap-legend.js","webpack:///./src/components/heatmap/heatmap.js","webpack:///./src/components/heatmap/canvas/convert-hue-to-rgb.js","webpack:///./src/components/heatmap/canvas/convert-rgb-to-hex.js","webpack:///./src/components/heatmap/canvas/convert-hsl-to-hex.js","webpack:///./src/components/heatmap/canvas/initialize-color-gradient.js","webpack:///./src/components/heatmap/canvas/set-range-partial.js","webpack:///./src/components/heatmap/canvas/draw-canvas.js","webpack:///./src/components/heatmap/heatmap-container.js","webpack:///./src/pages/heatmap/index.js"],"names":["Round","value","precision","multiplier","Math","round","debounce","func","wait","immediate","timeout","args","context","this","later","apply","callNow","clearTimeout","setTimeout","HeatmapLegend","className","Heatmap","forwardRef","refs","columns","highlightedPrey","rows","scrollerDimensions","translation","to","map","column","key","nav","ref","container","style","transform","row","canvas","defaultProps","propTypes","PropTypes","arrayOf","string","isRequired","shape","height","number","width","oneOfType","convertHuetoRGB","p","q","tInput","t","componentToHex","c","hex","toString","length","convertRGBtoHex","r","g","b","convertHSLtoHex","hsl","s","l","h","rgb","initializeColorGradient","colorSpace","numColors","increment","gradient","i","lightness","setRangePartial","inMin","inMax","outMin","outMax","inputRange","outputRange","inputNum","num","DPI","window","devicePixelRatio","createCanvas","data","dimensions","cellSize","ctx","getContext","clearRect","scale","cellDimension","colorGradient","convertToFillRange","partialSetRange","NUM_COLORS","forEach","rowIndex","y","columnIndex","x","fillStyle","fillRect","rowMap","reduce","accum","index","HeatmapContainer","useState","names","startIndex","setRows","setTranslation","canvasRef","useRef","containerRef","programmticScrollRef","urlPrey","useQueryParam","StringParam","updateCanvas","pageSize","pageSizeWithBuffer","dims","current","getBoundingClientRect","floor","numRows","containerHeightInCells","sliceStart","sliceEnd","ROW_BUFFER","maxTopRowIndex","getScrollToRow","pageRows","slice","pageValues","values","drawCanvas","debouncedUpdated","useEffect","desiredTopRowIndex","scrollTop","onScroll","topIndex","ceil","addEventListener","removeEventListener","HeatmapPage","footer","title"],"mappings":"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","file":"component---src-pages-heatmap-index-js-3f995d8a643c6e6cd8b4.js","sourcesContent":["const Round = (value, precision = 0) => {\n  const multiplier = 10 ** precision;\n  return Math.round(value * multiplier) / multiplier;\n};\n\nexport default Round;\n","/* Returns a function, that, as long as it continues to be invoked, will not\n** be triggered. The function will be called after it stops being called for\n** 'wait' milliseconds. If 'immediate' is passed, trigger the function on the\n** leading edge, instead of the trailing. */\n\nfunction debounce(func, wait, immediate) {\n  let timeout;\n  return function debounced(...args) {\n    const context = this;\n    const later = function delayedFunc() {\n      timeout = null;\n      if (!immediate) {\n        func.apply(context, args);\n      }\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) {\n      func.apply(context, args);\n    }\n  };\n}\n\nexport default debounce;\n","import React from 'react';\n\nconst HeatmapLegend = () => (\n  <span className=\"heatmap__legend\">Legend</span>\n);\n\nexport default HeatmapLegend;\n","import PropTypes from 'prop-types';\nimport React, { forwardRef } from 'react';\n\nimport HeatmapLegend from './heatmap-legend';\nimport Link from '../link/link';\n\nimport './heatmap.css';\n\nconst Heatmap = forwardRef((\n  {\n    columns,\n    highlightedPrey,\n    rows,\n    scrollerDimensions,\n    translation,\n  },\n  refs,\n) => (\n  <div className=\"heatmap\">\n    <h1>Viral-human proximity interaction heat map</h1>\n    <p>\n      Clustered heat map of spectral counts for all significant preys (FDR &le; 0.01) detected by viral\n      baits. An interactive version of this image can be viewed at\n      {' '}\n      <Link\n        to=\" https://prohits-viz.lunenfeld.ca/Interactive/index.html?input_tsv=archive/1596136776_GOUYUlT0me.txt&tool=Interactive\"\n      >\n        ProHits-viz\n      </Link>\n      .\n    </p>\n    <div className=\"heatmap__controls\">\n      <HeatmapLegend />\n    </div>\n    <div className=\"heatmap__columns-container\">\n      <div className=\"heatmap__columns\">\n        {\n          columns.map((column) => (\n            <Link\n              key={column}\n              nav\n              to={`/${column}`}\n            >\n              {column}\n            </Link>\n          ))\n        }\n      </div>\n    </div>\n    <div\n      className=\"heatmap__scroll-container\"\n      ref={refs.container}\n    >\n      <div\n        className=\"heatmap__scroller\"\n        style={scrollerDimensions}\n      >\n        <div\n          className=\"heatmap__rows\"\n          style={{ transform: `translateY(${translation}px)` }}\n        >\n          {\n            rows.map((row) => (\n              <div\n                className={highlightedPrey === row ? 'heatmap__highlight' : null}\n                key={row}\n              >\n                {row}\n              </div>\n            ))\n          }\n        </div>\n        <canvas\n          className=\"heatmap__canvas\"\n          ref={refs.canvas}\n          style={{ transform: `translateY(${translation}px)` }}\n        />\n      </div>\n    </div>\n  </div>\n));\n\nHeatmap.defaultProps = {\n  highlightedPrey: '',\n};\n\nHeatmap.propTypes = {\n  columns: PropTypes.arrayOf(PropTypes.string).isRequired,\n  highlightedPrey: PropTypes.string,\n  rows: PropTypes.arrayOf(PropTypes.string).isRequired,\n  scrollerDimensions: PropTypes.shape({\n    height: PropTypes.number,\n    width: PropTypes.number,\n  }).isRequired,\n  translation: PropTypes.oneOfType([\n    PropTypes.number,\n    PropTypes.string,\n  ]).isRequired,\n};\n\nexport default Heatmap;\n","// convertHuetoRGB converts a hue to rgb.\nconst convertHuetoRGB = (p, q, tInput) => {\n  let t = tInput;\n  if (t < 0) {\n    t += 1;\n  } else if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + ((q - p) * 6 * t);\n  } if (t < 0.5) {\n    return q;\n  } if (t < 2 / 3) {\n    return p + ((q - p) * ((2 / 3) - t) * 6);\n  }\n  return p;\n};\n\nexport default convertHuetoRGB;\n","// Convert an rgb tuple to hex;\n\nconst componentToHex = (c) => {\n  const hex = c.toString(16);\n  return hex.length === 1 ? `0${hex}` : hex;\n};\n\nconst convertRGBtoHex = (r, g, b) => (\n  `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`\n);\n\nexport default convertRGBtoHex;\n","import convertHuetoRGB from './convert-hue-to-rgb';\nimport convertRGBtoHex from './convert-rgb-to-hex';\n\n// convertHSLtoHex converts hsl colors to rgb to hex. Takes HSL values between 0 - 1 and\n// converts to range from 0 - 255, then converts to hex.\nconst convertHSLtoHex = (hsl) => {\n  let r;\n  let g;\n  let b;\n\n  if (hsl.s === 0) { // Achromatic.\n    r = hsl.l;\n    g = hsl.l;\n    b = hsl.l;\n  } else {\n    let q;\n    if (hsl.l < 0.5) {\n      q = hsl.l * (1 + hsl.s);\n    } else {\n      q = (hsl.l + hsl.s) - (hsl.l * hsl.s);\n    }\n    const p = (2 * hsl.l) - q;\n    r = convertHuetoRGB(p, q, hsl.h + (1 / 3));\n    g = convertHuetoRGB(p, q, hsl.h);\n    b = convertHuetoRGB(p, q, hsl.h - (1 / 3));\n  }\n  const rgb = {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255),\n  };\n  return convertRGBtoHex(rgb.r, rgb.g, rgb.b);\n};\n\nexport default convertHSLtoHex;\n","import convertHSLtoHex from './convert-hsl-to-hex';\nimport round from '../../../utils/round';\n\n// initializeColorGradient creates a single direction hex gradient. The color scale is set using the hue\n// and saturation components of HSL. The gradient is then defined by changing the lightness\n// from 1 (light) to 0 (dark). HSL values are on a 0-1 scale.\n// The maximum hue value of 1 equals 360 so all values are relative to that.\nconst initializeColorGradient = (colorSpace, numColors) => {\n  let h;\n  let s;\n  if (colorSpace === 'green') {\n    // Middle HSL value = (120, 100%, 50%).\n    h = 120 / 360;\n    s = 1;\n  } else if (colorSpace === 'greyscale') {\n    // Middle HSL value = (0, 0%, 50%).\n    h = 0;\n    s = 0;\n  } else if (colorSpace === 'red') {\n    // Middle HSL value = (0, 100%, 50%).\n    h = 0;\n    s = 1;\n  } else if (colorSpace === 'yellow') {\n    // Middle HSL value = (60, 100%, 50%).\n    h = 60 / 360;\n    s = 1;\n  } else { // default blue\n    // Middle (HSL value = (225, 100%, 50%).\n    h = 0.625;\n    s = 1;\n  }\n  const increment = 1 / (numColors - 1);\n  const startL = 1;\n  const gradient = [];\n  for (let i = 0; i < numColors; i += 1) {\n    const lightness = round(startL - (i * increment), 4);\n    gradient[i] = convertHSLtoHex({ h, s, l: lightness });\n  }\n  return gradient;\n};\n\nexport default initializeColorGradient;\n","/* Return a function that will map a number to an output integer range.\n** Checks to make sure the input number is within the input range. */\n\nconst setRangePartial = (inMin, inMax, outMin, outMax) => {\n  const inputRange = inMax - inMin;\n  const outputRange = outMax - outMin;\n  return (inputNum) => {\n    let num = inputNum;\n    if (inputNum > inMax) {\n      num = inMax;\n    } else if (inputNum < inMin) {\n      num = inMin;\n    }\n    return Math.round((((num - inMin) * outputRange) / inputRange) + outMin);\n  };\n};\n\nexport default setRangePartial;\n","/* eslint-disable no-param-reassign */\nimport initializeColorGradient from './initialize-color-gradient';\nimport partialSetRange from './set-range-partial';\n\nconst DPI = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\nconst NUM_COLORS = 101;\nconst SPEC_CAP = 50;\n\nconst createCanvas = (canvas, data, dimensions, cellSize) => {\n  canvas.style.height = `${dimensions.height}px`;\n  canvas.style.width = `${dimensions.width}px`;\n\n  canvas.height = dimensions.height * DPI;\n  canvas.width = dimensions.width * DPI;\n\n  const ctx = canvas.getContext('2d');\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.scale(DPI, DPI);\n\n  const cellDimension = cellSize * DPI;\n  const colorGradient = initializeColorGradient('blue', NUM_COLORS);\n  const convertToFillRange = partialSetRange(0, SPEC_CAP, 0, NUM_COLORS - 1);\n\n  data.forEach((row, rowIndex) => {\n    const y = rowIndex * cellSize;\n    row.forEach((value, columnIndex) => {\n      const x = columnIndex * cellSize;\n      ctx.fillStyle = colorGradient[convertToFillRange(value)];\n      ctx.fillRect(x, y, cellDimension, cellDimension);\n    });\n  });\n};\n\nexport default createCanvas;\n","import React, { useEffect, useRef, useState } from 'react';\nimport { useQueryParam, StringParam } from 'use-query-params';\n\nimport Heatmap from './heatmap';\n\nimport debounce from '../../utils/debounce';\nimport drawCanvas from './canvas/draw-canvas';\nimport data from './assets/heatmap-shape.json';\n\nconst rowMap = data.rows.reduce((accum, value, index) => ({ ...accum, [value]: index }), {});\n\nconst CELL_SIZE = 20;\nconst ROW_BUFFER = 20;\nconst HALF_ROW_BUFFER = ROW_BUFFER / 2;\n\nconst scrollerDimensions = {\n  height: data.rows.length * CELL_SIZE,\n  width: (data.columns.length * CELL_SIZE) + 100,\n};\n\nconst getDimensions = (container) => {\n  const { height } = container.getBoundingClientRect();\n\n  const pageSize = Math.floor(height / CELL_SIZE);\n  const pageSizeWithBuffer = pageSize + ROW_BUFFER;\n\n  return {\n    canvas: {\n      height: pageSizeWithBuffer * CELL_SIZE,\n      width: data.columns.length * CELL_SIZE,\n    },\n    numRows: data.rows.length,\n    pageSize,\n    pageSizeWithBuffer,\n  };\n};\n\nconst getScrollToRow = (container, rowIndex, dims) => {\n  const { height } = container.getBoundingClientRect();\n  const containerHeightInCells = Math.floor(height / CELL_SIZE);\n\n  if (rowIndex <= 0) {\n    return {\n      index: 0,\n      sliceStart: 0,\n      sliceEnd: dims.pageSizeWithBuffer,\n    };\n  } if (rowIndex <= HALF_ROW_BUFFER) {\n    return {\n      index: rowIndex,\n      sliceStart: 0,\n      sliceEnd: dims.pageSizeWithBuffer,\n    };\n  }\n\n  const maxTopRowIndex = dims.numRows - containerHeightInCells;\n  if (rowIndex >= maxTopRowIndex) {\n    return {\n      index: maxTopRowIndex,\n      sliceStart: maxTopRowIndex - ROW_BUFFER,\n      sliceEnd: dims.numRows,\n    };\n  } if (rowIndex >= maxTopRowIndex - HALF_ROW_BUFFER) {\n    return {\n      index: rowIndex,\n      sliceStart: dims.numRows - dims.pageSizeWithBuffer,\n      sliceEnd: dims.numRows,\n    };\n  }\n\n  return {\n    index: rowIndex,\n    sliceStart: rowIndex - HALF_ROW_BUFFER,\n    sliceEnd: rowIndex + dims.pageSize + HALF_ROW_BUFFER,\n  };\n};\n\nconst HeatmapContainer = () => {\n  const [rows, setRows] = useState({ names: [], startIndex: null });\n  const [translation, setTranslation] = useState(0);\n  const canvasRef = useRef();\n  const containerRef = useRef();\n  const programmticScrollRef = useRef(false);\n  const [urlPrey] = useQueryParam('prey', StringParam);\n\n  const updateCanvas = (rowIndex) => {\n    const dims = getDimensions(containerRef.current);\n    const row = getScrollToRow(containerRef.current, rowIndex, dims);\n    const pageRows = data.rows.slice(row.sliceStart, row.sliceEnd);\n    const pageValues = data.values.slice(row.sliceStart, row.sliceEnd);\n\n    drawCanvas(canvasRef.current, pageValues, dims.canvas, CELL_SIZE);\n    setRows({ names: pageRows, startIndex: row.sliceStart });\n    setTranslation(row.sliceStart * CELL_SIZE);\n\n    return row;\n  };\n  const debouncedUpdated = debounce(updateCanvas, 100);\n\n  useEffect(() => {\n    if (canvasRef.current && containerRef.current) {\n      const rowIndex = rowMap[urlPrey] || 0;\n      const { height } = containerRef.current.getBoundingClientRect();\n      const containerHeightInCells = Math.floor(height / CELL_SIZE);\n      const desiredTopRowIndex = rowIndex - Math.floor(containerHeightInCells / 2);\n\n      const row = updateCanvas(desiredTopRowIndex);\n      programmticScrollRef.current = true;\n      containerRef.current.scrollTop = row.index * CELL_SIZE;\n    }\n  }, [canvasRef.current, containerRef.current, urlPrey]);\n\n  useEffect(() => {\n    const onScroll = () => {\n      const topIndex = Math.ceil(containerRef.current.scrollTop / CELL_SIZE);\n      if (\n        !programmticScrollRef.current\n        && (\n          topIndex - rows.startIndex < 1\n          || topIndex - rows.startIndex > ROW_BUFFER - 1\n        )\n      ) {\n        debouncedUpdated(topIndex);\n      }\n      programmticScrollRef.current = false;\n    };\n\n    containerRef.current.addEventListener('scroll', onScroll);\n\n    return () => { containerRef.current.removeEventListener('scroll', onScroll); };\n  }, [containerRef.current, programmticScrollRef.current, rows.startIndex]);\n\n  return (\n    <Heatmap\n      columns={data.columns}\n      highlightedPrey={urlPrey}\n      ref={{\n        canvas: canvasRef,\n        container: containerRef,\n      }}\n      rows={rows.names}\n      scrollerDimensions={scrollerDimensions}\n      translation={translation}\n    />\n  );\n};\n\nexport default HeatmapContainer;\n","import React from 'react';\n\nimport Heatmap from '../../components/heatmap/heatmap-container';\nimport Layout from '../../components/layout/layout';\nimport SEO from '../../components/seo/seo';\n\nconst HeatmapPage = () => (\n  <Layout footer={false}>\n    <SEO title=\"Heat map\" />\n    <Heatmap />\n  </Layout>\n);\n\nexport default HeatmapPage;\n"],"sourceRoot":""}